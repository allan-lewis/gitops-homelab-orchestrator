---
## INSTALL DEVOPS PACKAGES USING PACMAN
- name: Ensure DevOps packages are installed (pacman)
  become: true
  community.general.pacman:
    name: "{{ arch_devops_pacman_packages }}"
    state: present
    update_cache: true
  tags: [devops, pkg-install]

- name: Gather pacman package facts (remote)
  ansible.builtin.package_facts:
    manager: pacman
  tags: [devops, pkg-facts]

- name: Assert requested packages are installed (remote)
  ansible.builtin.assert:
    that:
      - item in ansible_facts.packages
    fail_msg: "{{ item }} is NOT installed on remote host"
    success_msg: "{{ item }} is installed on remote host"
  loop: "{{ arch_devops_pacman_packages }}"
  tags: [devops, pkg-assert]

- name: Show installed package versions (from pacman facts)
  ansible.builtin.debug:
    msg: >-
      {{ item }}: {{
        (ansible_facts.packages[item] | first).version
      }}
  loop: "{{ arch_devops_pacman_packages }}"
  tags: [devops, pkg-versions]

## INSTALL AND CONFIGURE DOPPLER
- name: Determine whether a Doppler token is available
  ansible.builtin.set_fact:
    doppler_token_available: "{{ doppler_service_token | length > 0 }}"

- name: Ensure doppler_service_token is set and non-empty
  ansible.builtin.assert:
    that:
      - doppler_service_token is defined
      - doppler_service_token | length > 0
    fail_msg: "doppler_service_token must be set and non-empty"
  
- name: Download Doppler CLI install script
  become: true
  ansible.builtin.get_url:
    url: "https://cli.doppler.com/install.sh"
    dest: "/tmp/doppler-install.sh"
    mode: "0700"

- name: Run Doppler CLI install script
  become: true
  ansible.builtin.command:
    cmd: "sh /tmp/doppler-install.sh"
  register: doppler_install
  changed_when: false   # script may reinstall each time; keep run idempotent-ish
  failed_when: doppler_install.rc != 0

- name: Verify Doppler installation
  ansible.builtin.command:
    cmd: "doppler --version"
  register: doppler_version
  changed_when: false
  failed_when: doppler_version.rc != 0

- name: Display Doppler version (first line)
  ansible.builtin.debug:
    msg: "doppler: {{ (doppler_version.stdout | default('')).split('\n')[0] }}"

- name: Configure Doppler service token for scoped directory
  become: true
  become_user: "{{ ansible_user }}"
  ansible.builtin.shell: |
    set -o pipefail
    printf '%s\n' "$DOPPLER_SERVICE_TOKEN" | doppler configure set token --scope "{{ doppler_scope_dir }}"
  args:
    executable: /bin/bash
  environment:
    DOPPLER_SERVICE_TOKEN: "{{ doppler_service_token }}"
  changed_when: false
  when: doppler_token_available

- name: Configure Doppler project/config for scoped directory
  become: true
  become_user: "{{ ansible_user }}"
  ansible.builtin.command:
    cmd: >
      doppler setup
      --project {{ doppler_project }}
      --config {{ doppler_config }}
      --scope {{ doppler_scope_dir }}
      --no-interactive
  register: doppler_setup
  changed_when: false  # setup is effectively configuration; safe to treat as no-op
  failed_when: doppler_setup.rc != 0
  when: doppler_token_available

## CONFIGURE AWS
- name: Determine whether AWS credentials are available
  ansible.builtin.set_fact:
    aws_creds_available: >-
      {{ (aws_access_key_id | length > 0) and
         (aws_secret_access_key | length > 0) }}

- name: Fail if AWS credentials are missing or empty
  ansible.builtin.assert:
    that:
      - aws_creds_available
    fail_msg: "AWS credentials (aws_access_key_id + aws_secret_access_key) must be set and non-empty"

- name: Create AWS config dir
  become: true
  ansible.builtin.file:
    path: "{{ aws_cli_home }}/.aws"
    state: directory
    owner: "{{ aws_cli_user }}"
    group: "{{ aws_cli_user }}"
    mode: "0700"

- name: Ensure AWS config and credentials files exist
  become: true
  ansible.builtin.file:
    path: "{{ aws_cli_home }}/.aws/{{ item }}"
    state: touch
    owner: "{{ aws_cli_user }}"
    group: "{{ aws_cli_user }}"
    mode: "0600"
  loop:
    - config
    - credentials

- name: Configure default AWS profile in config
  become: true
  ansible.builtin.ini_file:
    path: "{{ aws_cli_home }}/.aws/config"
    section: default
    option: "{{ item.key }}"
    value: "{{ item.value }}"
    owner: "{{ aws_cli_user }}"
    group: "{{ aws_cli_user }}"
    mode: "0600"
  loop:
    - { key: "region",    value: "{{ aws_default_region }}" }
    - { key: "output",    value: "json" }
    - { key: "cli_pager", value: "" } 

- name: Configure default AWS credentials from env (if available)
  become: true
  no_log: true
  ansible.builtin.ini_file:
    path: "{{ aws_cli_home }}/.aws/credentials"
    section: default
    option: "{{ item.key }}"
    value: "{{ item.value }}"
    owner: "{{ aws_cli_user }}"
    group: "{{ aws_cli_user }}"
    mode: "0600"
  loop:
    - { key: "aws_access_key_id",     value: "{{ aws_access_key_id }}" }
    - { key: "aws_secret_access_key", value: "{{ aws_secret_access_key }}" }
  when: aws_creds_available

## CONFIGURE ANSIBLE
- name: Create the Ansible config directory
  become: true
  become_user: "{{ ansible_user }}"
  ansible.builtin.file:
    path: "/home/{{ ansible_user }}/.config/ansible"
    state: directory
    mode: "0755"
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"

- name: Write the Ansible config file
  become: true
  become_user: "{{ ansible_user }}"
  ansible.builtin.template:
    src: ansible.cfg.j2
    dest: "/home/{{ ansible_user }}/.config/ansible/ansible.cfg"
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"

- name: Clone the GitOps Homelab repo
  become: true
  become_user: "{{ ansible_user }}"
  ansible.builtin.git:
    repo: "https://github.com/allan-lewis/gitops-homelab.git"
    dest: "/home/{{ ansible_user }}/gitops-homelab"
    version: main
    update: yes
    force: no

## EXTRACT TF OUTPUTS FOR K8S AND TALOS
- name: Ensure required config directories exist
  become: true
  become_user: "{{ ansible_user }}"
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0700'
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
  with_items:
    - "/home/{{ ansible_user }}/.kube"
    - "/home/{{ ansible_user }}/.talos"

- name: Extract Terraform outputs (raw)
  become: true
  become_user: "{{ ansible_user }}"
  # no_log: true
  ansible.builtin.shell: |
    doppler run -- terraform output -raw {{ item }}
  args:
    chdir: "{{ terraform_environment_dir }}"
    executable: /bin/bash
  register: tf_output_results
  loop:
    - "kubeconfig"
    - "talosconfig"

- name: Build map of Terraform outputs
  no_log: true
  ansible.builtin.set_fact:
    tf_outputs: "{{ tf_outputs | default({}) | combine({ item.item: item.stdout }) }}"
  loop: "{{ tf_output_results.results }}"

- name: Write kubeconfig from Terraform output
  become: tf_output_results
  become_user: "{{ ansible_user }}"
  no_log: true
  ansible.builtin.copy:
    dest: "/home/{{ ansible_user }}/.kube/config"
    mode: '0600'
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    content: "{{ tf_outputs.kubeconfig }}"

- name: Write talosconfig from Terraform output
  become: tf_output_results
  become_user: "{{ ansible_user }}"
  no_log: true
  ansible.builtin.copy:
    dest: "/home/{{ ansible_user }}/.talos/config"
    mode: '0600'
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    content: "{{ tf_outputs.talosconfig }}"

## KUBECTL SANITY TEST
- name: Verify kubectl is functional and cluster is reachable
  become: true
  become_user: "{{ ansible_user }}"
  ansible.builtin.command: kubectl get nodes --no-headers
  register: _kubectl_checks
  changed_when: false
  failed_when: _kubectl_checks.rc != 0
  no_log: true

## TALOSCTL SANITY TEST
- name: Configure talosctl node (for no-args health call)
  become: true
  become_user: "{{ ansible_user }}"
  no_log: true
  ansible.builtin.command: >
    talosctl config node {{ terraform_output_config_node }}
  changed_when: false

- name: Verify talosctl is functional and cluster is healthy
  become: true
  become_user: "{{ ansible_user }}"
  ansible.builtin.command: talosctl health
  register: _talosctl_checks
  changed_when: false
  failed_when: _talosctl_checks.rc != 0
  no_log: true
